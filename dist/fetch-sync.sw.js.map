{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6","webpack:///webpack/bootstrap 41bf766f1e9775b1db06?b1ea","webpack:///C:/xampp/htdocs/fetch-sync/fetchSync/constants.js?1d5a","webpack:///C:/xampp/htdocs/fetch-sync/fetchSync/actionTypes.js?7767","webpack:///./~/serialise-request/dist/serialise-request.min.js?44a5","webpack:///./~/serialise-response/index.js?fad1","webpack:///C:/xampp/htdocs/fetch-sync/fetchSync/worker/Channel.js","webpack:///./~/idb-wrapper/idbstore.js","webpack:///C:/xampp/htdocs/fetch-sync/fetchSync/worker/index.js"],"names":[],"mappings":"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CA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA,2BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;;AAEP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAW;AACX;AACA;AACA;;AAEA,UAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA,QAAO;;AAEP;;AAEA;;AAEA;AACA;AACA,UAAS;AACT,qCAAoC;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAoE,6DAA6D;AACjI;;AAEA;AACA,YAAW;AACX,mEAAkE,6DAA6D;AAC/H;;AAEA,UAAS;;AAET;AACA;AACA;AACA,YAAW;AACX;;AAEA,QAAO;AACP,MAAK;;AAEL;AACA;AACA;AACA;AACA,gBAAe,SAAS;AACxB;AACA,gBAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAiC;AACjC;AACA,gBAAe,EAAE;AACjB;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,SAAS;AACxB;AACA,gBAAe,SAAS;AACxB;AACA,kBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAkC;AAClC;AACA;AACA,QAAO,OAAO;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,gBAAe,EAAE;AACjB,gBAAe,SAAS;AACxB;AACA,gBAAe,SAAS;AACxB;AACA,kBAAiB,eAAe;AAChC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA,gBAAe,EAAE;AACjB,gBAAe,SAAS;AACxB;AACA,gBAAe,SAAS;AACxB;AACA,kBAAiB,eAAe;AAChC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA,gBAAe,MAAM;AACrB;AACA,gBAAe,SAAS;AACxB;AACA,gBAAe,SAAS;AACxB;AACA,kBAAiB,eAAe;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,uCAAsC;AACtC;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA,MAAK;;AAEL;AACA;AACA;AACA,gBAAe,MAAM;AACrB,gBAAe,SAAS;AACxB;AACA,gBAAe,SAAS;AACxB;AACA,kBAAiB,eAAe;AAChC;AACA;AACA;AACA,iBAAgB;AAChB,QAAO;;AAEP;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,MAAM;AACrB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB;AACA,gBAAe,SAAS;AACxB;AACA,gBAAe,SAAS;AACxB;AACA,kBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA8B;;AAE9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAoB;;AAEpB;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAoC;AACpC;AACA;AACA,UAAS,OAAO;AAChB;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,gBAAe,MAAM;AACrB,gBAAe,SAAS;AACxB;AACA,gBAAe,SAAS;AACxB;AACA,kBAAiB,eAAe;AAChC;AACA;AACA;AACA,iBAAgB;AAChB,QAAO;;AAEP;AACA,MAAK;;AAEL;AACA;AACA;AACA,gBAAe,MAAM;AACrB,gBAAe,SAAS;AACxB;AACA,gBAAe,SAAS;AACxB;AACA,gBAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,kBAAiB,eAAe;AAChC;AACA;AACA;AACA,4DAA2D,IAAI;;AAE/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,QAAO;;AAEP;AACA,MAAK;;AAEL;AACA;AACA;AACA,gBAAe,SAAS;AACxB;AACA,gBAAe,SAAS;AACxB;AACA,kBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,SAAS;AACxB;AACA,gBAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,SAAS;AACxB;AACA,gBAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,gBAAe,SAAS;AACxB;AACA,gBAAe,SAAS;AACxB;AACA,kBAAiB,eAAe;AAChC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAgB,cAAc;AAC9B;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,gBAAe,OAAO;AACtB,iBAAgB,QAAQ;AACxB;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,QAAQ;AACvB,gBAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,iBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,0CAAyC,KAAK;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAe,SAAS;AACxB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB;AACA,gBAAe,QAAQ;AACvB;AACA,gBAAe,QAAQ;AACvB;AACA,gBAAe,OAAO;AACtB,gBAAe,QAAQ;AACvB;AACA,gBAAe,SAAS;AACxB;AACA,gBAAe,SAAS;AACxB;AACA,gBAAe,OAAO;AACtB;AACA,gBAAe,OAAO;AACtB;AACA,kBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO,eAAe;;AAEtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,gBAAe,SAAS;AACxB;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB;AACA,gBAAe,QAAQ;AACvB;AACA,gBAAe,OAAO;AACtB,gBAAe,SAAS;AACxB;AACA,gBAAe,OAAO;AACtB;AACA,gBAAe,OAAO;AACtB;AACA,kBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,gBAAe,SAAS;AACxB;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,SAAS;AACxB;AACA,kBAAiB,eAAe;AAChC;AACA;;AAEA;AACA;AACA;AACA,QAAO,eAAe;;AAEtB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,EAAE;AACjB,gBAAe,QAAQ;AACvB;AACA,gBAAe,EAAE;AACjB,gBAAe,QAAQ;AACvB;AACA,gBAAe,EAAE;AACjB;AACA;AACA,iBAAgB,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","file":"fetch-sync.sw.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"fetchSync\"] = factory();\n\telse\n\t\troot[\"fetchSync\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// on error function for async loading\n \t__webpack_require__.oe = function(err) { throw err; };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 16);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 41bf766f1e9775b1db06\n **/","'use strict'\r\n\r\nexport const SyncIdPrefix = 'FETCH_SYNC__'\r\n\r\nexport const SyncTypes = {\r\n  SYNC: 'sync',\r\n  PERIODIC_SYNC: 'periodicSync'\r\n}\r\n\r\nexport const CommsChannelStatus = {\r\n  OPEN: 1,\r\n  CLOSED: 0\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** C:/xampp/htdocs/fetch-sync/fetchSync/constants.js\n **/","'use strict'\n\nexport const ADD_SYNC = 'ADD_SYNC'\nexport const ADD_SYNCS = 'ADD_SYNCS'\n\nexport const REMOVE_SYNC = 'REMOVE_SYNC'\nexport const REMOVE_ALL_SYNCS = 'REMOVE_ALL_SYNCS'\n\nexport const SET_SERVICE_WORKER = 'SET_SERVICE_WORKER'\nexport const SET_COMMS_OPEN = 'SET_COMMS_OPEN'\n\nexport const Requests = {\n  OPEN_COMMS: 'OPEN_COMMS',\n  REGISTER_SYNC: 'REGISTER_SYNC',\n  CANCEL_SYNC: 'CANCEL_SYNC',\n  CANCEL_ALL: 'CANCEL_ALL'\n}\n\nexport const Responses = {\n  SUCCESS: 'SUCCESS',\n  FAILURE: 'FAILURE'\n}\n\n\n\n/** WEBPACK FOOTER **\n ** C:/xampp/htdocs/fetch-sync/fetchSync/actionTypes.js\n **/","!function(e,t){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define([],t):\"object\"==typeof exports?exports.serialiseRequest=t():e.serialiseRequest=t()}(this,function(){return function(e){function t(r){if(n[r])return n[r].exports;var o=n[r]={exports:{},id:r,loaded:!1};return e[r].call(o.exports,o,o.exports,t),o.loaded=!0,o.exports}var n={};return t.m=e,t.c=n,t.p=\"\",t(0)}([function(e,t,n){function r(e){return s.blobToArrayBuffer(e).then(function(e){return String.fromCharCode.apply(null,new Uint16Array(e))})}function o(e,t){return s.base64StringToBlob(e).then(function(e){switch(t){case c.ARRAY_BUFFER:return s.blobToArrayBuffer(e);case c.BLOB:return e;case c.FORM_DATA:throw new Error(\"Cannot make FormData from serialised Request\");case c.JSON:return r(e).then(function(e){return JSON.parse(e)});case c.TEXT:return r(e);default:throw new Error('Unknown requested body type \"'+t+'\"')}})}function i(e,t){if(!(e instanceof Request))throw new Error(\"Expecting request to be instance of Request\");for(var n=[],r=e.headers.keys(),o=0;o<r.length;o++){var i=r[o];n[i]=e.headers.get(i)}var u={method:e.method,url:e.url,headers:n,context:e.context,referrer:e.referrer,mode:e.mode,credentials:e.credentials,redirect:e.redirect,integrity:e.integrity,cache:e.cache,bodyUsed:e.bodyUsed};return e.blob().then(s.blobToBase64String).then(function(e){return u.__body=e,t?u:JSON.stringify(u)})}function u(e){var t,n;if(\"string\"==typeof e)t=JSON.parse(e),n=t.url;else{if(\"object\"!=typeof e)throw new Error(\"Expecting serialised request to be a string or object\");t=e,n=t.url}const r=new Request(n,t),i={context:{enumerable:!0,value:t.context}},u=Object.keys(c).reduce(function(e,n){const i=f[n];return e[i]={enumerable:!0,value:function(){return r.bodyUsed?Promise.reject(new TypeError(\"Already used\")):(r.bodyUsed=!0,Promise.resolve(o(t.__body,n)))}},e},i);return Object.defineProperties(r,u),r}var a,a,s=n(1),c={ARRAY_BUFFER:\"ARRAY_BUFFER\",BLOB:\"BLOB\",FORM_DATA:\"FORM_DATA\",JSON:\"JSON\",TEXT:\"TEXT\"},f={ARRAY_BUFFER:\"arrayBuffer\",BLOB:\"blob\",FORM_DATA:\"formData\",JSON:\"json\",TEXT:\"text\"};i.deserialise=u,i.deserialize=u,a=function(){return i}.call(t,n,t,e),!(void 0!==a&&(e.exports=a)),a=function(){return i}.call(t,n,t,e),!(void 0!==a&&(e.exports=a))},function(e,t,n){\"use strict\";function r(e){for(var t=e.length,n=new ArrayBuffer(t),r=new Uint8Array(n),o=-1;++o<t;)r[o]=e.charCodeAt(o);return n}function o(e){for(var t=\"\",n=new Uint8Array(e),r=n.byteLength,o=-1;++o<r;)t+=String.fromCharCode(n[o]);return t}function i(e,t){return new R(function(n,r){var o=new Image;t&&(o.crossOrigin=t),o.onload=function(){n(o)},o.onerror=r,o.src=e})}function u(e){var t=document.createElement(\"canvas\");t.width=e.width,t.height=e.height;var n=t.getContext(\"2d\");return n.drawImage(e,0,0,e.width,e.height,0,0,e.width,e.height),t}function a(e,t){return t=t||{},\"string\"==typeof t&&(t={type:t}),new g(e,t)}function s(e){return(window.URL||window.webkitURL).createObjectURL(e)}function c(e){return(window.URL||window.webkitURL).revokeObjectURL(e)}function f(e){return new R(function(t,n){var r=new FileReader,i=\"function\"==typeof r.readAsBinaryString;r.onloadend=function(e){var n=e.target.result||\"\";return i?t(n):void t(o(n))},r.onerror=n,i?r.readAsBinaryString(e):r.readAsArrayBuffer(e)})}function l(e,t){return R.resolve().then(function(){var n=[r(atob(e))];return t?a(n,{type:t}):a(n)})}function d(e,t){return R.resolve().then(function(){return l(btoa(e),t)})}function h(e){return f(e).then(function(e){return btoa(e)})}function p(e){return R.resolve().then(function(){var t=e.match(/data:([^;]+)/)[1],n=e.replace(/^[^,]+,/,\"\"),o=r(atob(n));return a([o],{type:t})})}function v(e,t,n,r){return t=t||\"image/png\",i(e,n).then(function(e){return u(e)}).then(function(e){return e.toDataURL(t,r)})}function y(e,t,n){return R.resolve().then(function(){return\"function\"==typeof e.toBlob?new R(function(r){e.toBlob(r,t,n)}):p(e.toDataURL(t,n))})}function b(e,t,n,r){return t=t||\"image/png\",i(e,n).then(function(e){return u(e)}).then(function(e){return y(e,t,r)})}function w(e,t){return R.resolve().then(function(){return a([e],t)})}function m(e){return new R(function(t,n){var r=new FileReader;r.onloadend=function(e){var n=e.target.result||new ArrayBuffer(0);t(n)},r.onerror=n,r.readAsArrayBuffer(e)})}var g=n(2),R=n(3);e.exports={createBlob:a,createObjectURL:s,revokeObjectURL:c,imgSrcToBlob:b,imgSrcToDataURL:v,canvasToBlob:y,dataURLToBlob:p,blobToBase64String:h,base64StringToBlob:l,binaryStringToBlob:d,blobToBinaryString:f,arrayBufferToBlob:w,blobToArrayBuffer:m}},function(e,t){(function(t){function n(e){for(var t=0;t<e.length;t++){var n=e[t];if(n.buffer instanceof ArrayBuffer){var r=n.buffer;if(n.byteLength!==r.byteLength){var o=new Uint8Array(n.byteLength);o.set(new Uint8Array(r,n.byteOffset,n.byteLength)),r=o.buffer}e[t]=r}}}function r(e,t){t=t||{};var r=new i;n(e);for(var o=0;o<e.length;o++)r.append(e[o]);return t.type?r.getBlob(t.type):r.getBlob()}function o(e,t){return n(e),new Blob(e,t||{})}var i=t.BlobBuilder||t.WebKitBlobBuilder||t.MSBlobBuilder||t.MozBlobBuilder,u=function(){try{var e=new Blob([\"hi\"]);return 2===e.size}catch(t){return!1}}(),a=u&&function(){try{var e=new Blob([new Uint8Array([1,2])]);return 2===e.size}catch(t){return!1}}(),s=i&&i.prototype.append&&i.prototype.getBlob;e.exports=function(){return u?a?t.Blob:o:s?r:void 0}()}).call(t,function(){return this}())},function(e,t,n){(function(t){\"function\"==typeof t.Promise?e.exports=t.Promise:e.exports=n(4)}).call(t,function(){return this}())},function(e,t,n){var r,r;!function(t){e.exports=t()}(function(){return function e(t,n,o){function i(a,s){if(!n[a]){if(!t[a]){var c=\"function\"==typeof r&&r;if(!s&&c)return r(a,!0);if(u)return u(a,!0);throw new Error(\"Cannot find module '\"+a+\"'\")}var f=n[a]={exports:{}};t[a][0].call(f.exports,function(e){var n=t[a][1][e];return i(n?n:e)},f,f.exports,e,t,n,o)}return n[a].exports}for(var u=\"function\"==typeof r&&r,a=0;a<o.length;a++)i(o[a]);return i}({1:[function(e,t,n){\"use strict\";function r(){}t.exports=r},{}],2:[function(e,t,n){\"use strict\";var r=e(\"./promise\"),o=e(\"./reject\"),i=e(\"./resolve\"),u=e(\"./INTERNAL\"),a=e(\"./handlers\"),s=o(new TypeError(\"must be an array\"));t.exports=function(e){function t(e,t){function r(e){c[t]=e,++f===n&!o&&(o=!0,a.resolve(d,c))}i(e).then(r,function(e){o||(o=!0,a.reject(d,e))})}if(\"[object Array]\"!==Object.prototype.toString.call(e))return s;var n=e.length,o=!1;if(!n)return i([]);for(var c=new Array(n),f=0,l=-1,d=new r(u);++l<n;)t(e[l],l);return d}},{\"./INTERNAL\":1,\"./handlers\":3,\"./promise\":5,\"./reject\":7,\"./resolve\":8}],3:[function(e,t,n){\"use strict\";function r(e){var t=e&&e.then;return e&&\"object\"==typeof e&&\"function\"==typeof t?function(){t.apply(e,arguments)}:void 0}var o=e(\"./tryCatch\"),i=e(\"./resolveThenable\"),u=e(\"./states\");n.resolve=function(e,t){var a=o(r,t);if(\"error\"===a.status)return n.reject(e,a.value);var s=a.value;if(s)i.safely(e,s);else{e.state=u.FULFILLED,e.outcome=t;for(var c=-1,f=e.queue.length;++c<f;)e.queue[c].callFulfilled(t)}return e},n.reject=function(e,t){e.state=u.REJECTED,e.outcome=t;for(var n=-1,r=e.queue.length;++n<r;)e.queue[n].callRejected(t);return e}},{\"./resolveThenable\":9,\"./states\":10,\"./tryCatch\":11}],4:[function(e,t,n){t.exports=n=e(\"./promise\"),n.resolve=e(\"./resolve\"),n.reject=e(\"./reject\"),n.all=e(\"./all\")},{\"./all\":2,\"./promise\":5,\"./reject\":7,\"./resolve\":8}],5:[function(e,t,n){\"use strict\";function r(e){if(!(this instanceof r))return new r(e);if(\"function\"!=typeof e)throw new TypeError(\"reslover must be a function\");this.state=a.PENDING,this.queue=[],this.outcome=void 0,e!==i&&u.safely(this,e)}var o=e(\"./unwrap\"),i=e(\"./INTERNAL\"),u=e(\"./resolveThenable\"),a=e(\"./states\"),s=e(\"./queueItem\");t.exports=r,r.prototype[\"catch\"]=function(e){return this.then(null,e)},r.prototype.then=function(e,t){if(\"function\"!=typeof e&&this.state===a.FULFILLED||\"function\"!=typeof t&&this.state===a.REJECTED)return this;var n=new r(i);if(this.state!==a.PENDING){var u=this.state===a.FULFILLED?e:t;o(n,u,this.outcome)}else this.queue.push(new s(n,e,t));return n}},{\"./INTERNAL\":1,\"./queueItem\":6,\"./resolveThenable\":9,\"./states\":10,\"./unwrap\":12}],6:[function(e,t,n){\"use strict\";function r(e,t,n){this.promise=e,\"function\"==typeof t&&(this.onFulfilled=t,this.callFulfilled=this.otherCallFulfilled),\"function\"==typeof n&&(this.onRejected=n,this.callRejected=this.otherCallRejected)}var o=e(\"./handlers\"),i=e(\"./unwrap\");t.exports=r,r.prototype.callFulfilled=function(e){o.resolve(this.promise,e)},r.prototype.otherCallFulfilled=function(e){i(this.promise,this.onFulfilled,e)},r.prototype.callRejected=function(e){o.reject(this.promise,e)},r.prototype.otherCallRejected=function(e){i(this.promise,this.onRejected,e)}},{\"./handlers\":3,\"./unwrap\":12}],7:[function(e,t,n){\"use strict\";function r(e){var t=new o(i);return u.reject(t,e)}var o=e(\"./promise\"),i=e(\"./INTERNAL\"),u=e(\"./handlers\");t.exports=r},{\"./INTERNAL\":1,\"./handlers\":3,\"./promise\":5}],8:[function(e,t,n){\"use strict\";function r(e){if(e)return e instanceof o?e:u.resolve(new o(i),e);var t=typeof e;switch(t){case\"boolean\":return a;case\"undefined\":return c;case\"object\":return s;case\"number\":return f;case\"string\":return l}}var o=e(\"./promise\"),i=e(\"./INTERNAL\"),u=e(\"./handlers\");t.exports=r;var a=u.resolve(new o(i),!1),s=u.resolve(new o(i),null),c=u.resolve(new o(i),void 0),f=u.resolve(new o(i),0),l=u.resolve(new o(i),\"\")},{\"./INTERNAL\":1,\"./handlers\":3,\"./promise\":5}],9:[function(e,t,n){\"use strict\";function r(e,t){function n(t){a||(a=!0,o.reject(e,t))}function r(t){a||(a=!0,o.resolve(e,t))}function u(){t(r,n)}var a=!1,s=i(u);\"error\"===s.status&&n(s.value)}var o=e(\"./handlers\"),i=e(\"./tryCatch\");n.safely=r},{\"./handlers\":3,\"./tryCatch\":11}],10:[function(e,t,n){n.REJECTED=[\"REJECTED\"],n.FULFILLED=[\"FULFILLED\"],n.PENDING=[\"PENDING\"]},{}],11:[function(e,t,n){\"use strict\";function r(e,t){var n={};try{n.value=e(t),n.status=\"success\"}catch(r){n.status=\"error\",n.value=r}return n}t.exports=r},{}],12:[function(e,t,n){\"use strict\";function r(e,t,n){o(function(){var r;try{r=t(n)}catch(o){return i.reject(e,o)}r===e?i.reject(e,new TypeError(\"Cannot resolve promise with itself\")):i.resolve(e,r)})}var o=e(\"immediate\"),i=e(\"./handlers\");t.exports=r},{\"./handlers\":3,immediate:13}],13:[function(e,t,n){\"use strict\";function r(){i=!0;for(var e,t,n=s.length;n;){for(t=s,s=[],e=-1;++e<n;)t[e]();n=s.length}i=!1}function o(e){1!==s.push(e)||i||u()}for(var i,u,a=[e(\"./nextTick\"),e(\"./messageChannel\"),e(\"./stateChange\"),e(\"./timeout\")],s=[],c=-1,f=a.length;++c<f;)if(a[c].test()){u=a[c].install(r);break}t.exports=o},{\"./messageChannel\":14,\"./nextTick\":15,\"./stateChange\":16,\"./timeout\":17}],14:[function(e,t,n){(function(e){\"use strict\";n.test=function(){return e.setImmediate?!1:\"undefined\"!=typeof e.MessageChannel},n.install=function(t){var n=new e.MessageChannel;return n.port1.onmessage=t,function(){n.port2.postMessage(0)}}}).call(this,\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{})},{}],15:[function(e,t,n){(function(e){\"use strict\";var t=e.MutationObserver||e.WebKitMutationObserver;n.test=function(){return t},n.install=function(n){var r=0,o=new t(n),i=e.document.createTextNode(\"\");return o.observe(i,{characterData:!0}),function(){i.data=r=++r%2}}}).call(this,\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{})},{}],16:[function(e,t,n){(function(e){\"use strict\";n.test=function(){return\"document\"in e&&\"onreadystatechange\"in e.document.createElement(\"script\")},n.install=function(t){return function(){var n=e.document.createElement(\"script\");return n.onreadystatechange=function(){t(),n.onreadystatechange=null,n.parentNode.removeChild(n),n=null},e.document.documentElement.appendChild(n),t}}}).call(this,\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{})},{}],17:[function(e,t,n){\"use strict\";n.test=function(){return!0},n.install=function(e){return function(){setTimeout(e,0)}}},{}]},{},[4])(4)})}])});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/serialise-request/dist/serialise-request.min.js\n ** module id = 2\n ** module chunks = 0 1\n **/","'use strict'\n\n/* global Response:false, FileReader:false */\n\n// https://gist.github.com/davoclavo/4424731\nfunction dataURItoBlob (dataURI) {\n  var byteString = atob(dataURI.split(',')[1])\n  var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0]\n  var arrayBuffer = new ArrayBuffer(byteString.length)\n  var _ia = new Uint8Array(arrayBuffer)\n  for (var i = 0; i < byteString.length; i++) {\n    _ia[i] = byteString.charCodeAt(i)\n  }\n  var dataView = new DataView(arrayBuffer)\n  return new Blob([dataView.buffer], {type: mimeString})\n}\n\n/**\n * Serialise a Response to a string or object.\n * @param {Response} response\n */\nfunction serialiseResponse (response) {\n  if (!(response instanceof Response)) {\n    throw new Error('Expecting response to be instance of Response')\n  }\n\n  var headers = []\n  var headerNames = response.headers.keys()\n  for (var i = 0; i < headerNames.length; i++) {\n    var headerName = headerNames[i]\n    headers[headerName] = response.headers.get(headerName)\n  }\n\n  return new Promise(function (resolve, reject) {\n    var reader = new FileReader()\n    response.blob().then(function (blob) {\n      return reader.readAsDataURL(blob)\n    })\n    reader.onerror = reject\n    reader.onloadend = function () {\n      resolve(JSON.stringify({\n        type: response.type,\n        url: response.url,\n        useFinalURL: response.useFinalURL,\n        status: response.status,\n        ok: response.ok,\n        statusText: response.statusText,\n        headers: headers,\n        __body: reader.result\n      }))\n    }\n  })\n}\n\n/**\n * De-serialise a Response from a string or object.\n * @param {Object|String} response\n */\nfunction deserialiseResponse (response) {\n  var realResponse\n\n  if (typeof response === 'string') {\n    realResponse = JSON.parse(response)\n  } else if (typeof response === 'object') {\n    realResponse = response\n  } else {\n    throw new Error('Expecting serialised response to be a string or object')\n  }\n\n  return new Response(dataURItoBlob(realResponse.__body))\n}\n\nserialiseResponse.deserialise = deserialiseResponse\nserialiseResponse.deserialize = deserialiseResponse\n\n/* global define:false window:false */\nif (typeof define === 'function' && define.amd) {\n  define('serialiseResponse', function () {\n    return serialiseResponse\n  })\n  define('serializeResponse', function () {\n    return serialiseResponse\n  })\n} else if (typeof module === 'object' && module.exports) {\n  module.exports = serialiseResponse\n} else if (typeof window !== 'undefined') {\n  window.serialiseResponse = serialiseResponse\n  window.serializeResponse = serialiseResponse\n} else {\n  throw new Error(\n    'Environment is not supported. ' +\n    'Please raise an issue at https://github.com/sdgluck/serialise-response/issues'\n  )\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/serialise-response/index.js\n ** module id = 4\n ** module chunks = 0 1\n **/","'use strict'\r\n\r\nimport { Responses } from '/fetchSync/actionTypes'\r\n\r\nexport default class Channel {\r\n  constructor (worker, messageHandlers) {\r\n    worker.onmessage = this.onMessageEvent.bind(this)\r\n    this.messageHandlers = messageHandlers\r\n    this.defaultPort = null\r\n  }\r\n\r\n  setDefaultPort (defaultPort) {\r\n    this.defaultPort = defaultPort\r\n  }\r\n\r\n  postMessage (data, port) {\r\n    if (port) {\r\n      port.postMessage(JSON.stringify(data))\r\n    } else if (this.defaultPort) {\r\n      this.defaultPort.postMessage(JSON.stringify(data))\r\n    } else {\r\n      throw new Error('No port available')\r\n    }\r\n  }\r\n\r\n  handleMessage (event) {\r\n    const request = event.data\r\n    if (request.type in this.messageHandlers) {\r\n      return this.messageHandlers[request.type](event)\r\n    }\r\n    return Promise.reject(new Error(`Unknown request type \"${request.type}\"`))\r\n  }\r\n\r\n  onMessageEvent (event) {\r\n    return this\r\n      .handleMessage(event)\r\n      .catch((err) => this.postMessage({\r\n        type: Responses.FAILURE,\r\n        data: { error: err.message }\r\n      }, event.ports[0]))\r\n      .then((data) => this.postMessage({\r\n        type: Responses.SUCCESS,\r\n        data\r\n      }, event.ports[0]))\r\n  }\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** C:/xampp/htdocs/fetch-sync/fetchSync/worker/Channel.js\n **/","/*global window:false, self:false, define:false, module:false */\n\n/**\n * @license IDBWrapper - A cross-browser wrapper for IndexedDB\n * Version 1.6.2\n * Copyright (c) 2011 - 2016 Jens Arps\n * http://jensarps.de/\n *\n * Licensed under the MIT (X11) license\n */\n\n(function (name, definition, global) {\n\n  'use strict';\n\n  if (typeof define === 'function') {\n    define(definition);\n  } else if (typeof module !== 'undefined' && module.exports) {\n    module.exports = definition();\n  } else {\n    global[name] = definition();\n  }\n})('IDBStore', function () {\n\n  'use strict';\n\n  var defaultErrorHandler = function (error) {\n    throw error;\n  };\n  var defaultSuccessHandler = function () {};\n\n  var defaults = {\n    storeName: 'Store',\n    storePrefix: 'IDBWrapper-',\n    dbVersion: 1,\n    keyPath: 'id',\n    autoIncrement: true,\n    onStoreReady: function () {\n    },\n    onError: defaultErrorHandler,\n    indexes: [],\n    implementationPreference: [\n      'indexedDB',\n      'webkitIndexedDB',\n      'mozIndexedDB',\n      'shimIndexedDB'\n    ]\n  };\n\n  /**\n   *\n   * The IDBStore constructor\n   *\n   * @constructor\n   * @name IDBStore\n   * @version 1.6.2\n   *\n   * @param {Object} [kwArgs] An options object used to configure the store and\n   *  set callbacks\n   * @param {String} [kwArgs.storeName='Store'] The name of the store\n   * @param {String} [kwArgs.storePrefix='IDBWrapper-'] A prefix that is\n   *  internally used to construct the name of the database, which will be\n   *  kwArgs.storePrefix + kwArgs.storeName\n   * @param {Number} [kwArgs.dbVersion=1] The version of the store\n   * @param {String} [kwArgs.keyPath='id'] The key path to use. If you want to\n   *  setup IDBWrapper to work with out-of-line keys, you need to set this to\n   *  `null`\n   * @param {Boolean} [kwArgs.autoIncrement=true] If set to true, IDBStore will\n   *  automatically make sure a unique keyPath value is present on each object\n   *  that is stored.\n   * @param {Function} [kwArgs.onStoreReady] A callback to be called when the\n   *  store is ready to be used.\n   * @param {Function} [kwArgs.onError=throw] A callback to be called when an\n   *  error occurred during instantiation of the store.\n   * @param {Array} [kwArgs.indexes=[]] An array of indexData objects\n   *  defining the indexes to use with the store. For every index to be used\n   *  one indexData object needs to be passed in the array.\n   *  An indexData object is defined as follows:\n   * @param {Object} [kwArgs.indexes.indexData] An object defining the index to\n   *  use\n   * @param {String} kwArgs.indexes.indexData.name The name of the index\n   * @param {String} [kwArgs.indexes.indexData.keyPath] The key path of the index\n   * @param {Boolean} [kwArgs.indexes.indexData.unique] Whether the index is unique\n   * @param {Boolean} [kwArgs.indexes.indexData.multiEntry] Whether the index is multi entry\n   * @param {Array} [kwArgs.implementationPreference=['indexedDB','webkitIndexedDB','mozIndexedDB','shimIndexedDB']] An array of strings naming implementations to be used, in order or preference\n   * @param {Function} [onStoreReady] A callback to be called when the store\n   * is ready to be used.\n   * @example\n      // create a store for customers with an additional index over the\n      // `lastname` property.\n      var myCustomerStore = new IDBStore({\n        dbVersion: 1,\n        storeName: 'customer-index',\n        keyPath: 'customerid',\n        autoIncrement: true,\n        onStoreReady: populateTable,\n        indexes: [\n          { name: 'lastname', keyPath: 'lastname', unique: false, multiEntry: false }\n        ]\n      });\n   * @example\n      // create a generic store\n      var myCustomerStore = new IDBStore({\n        storeName: 'my-data-store',\n        onStoreReady: function(){\n          // start working with the store.\n        }\n      });\n   */\n  var IDBStore = function (kwArgs, onStoreReady) {\n\n    if (typeof onStoreReady == 'undefined' && typeof kwArgs == 'function') {\n      onStoreReady = kwArgs;\n    }\n    if (Object.prototype.toString.call(kwArgs) != '[object Object]') {\n      kwArgs = {};\n    }\n\n    for (var key in defaults) {\n      this[key] = typeof kwArgs[key] != 'undefined' ? kwArgs[key] : defaults[key];\n    }\n\n    this.dbName = this.storePrefix + this.storeName;\n    this.dbVersion = parseInt(this.dbVersion, 10) || 1;\n\n    onStoreReady && (this.onStoreReady = onStoreReady);\n\n    var env = typeof window == 'object' ? window : self;\n    var availableImplementations = this.implementationPreference.filter(function (implName) {\n      return implName in env;\n    });\n    this.implementation = availableImplementations[0];\n    this.idb = env[this.implementation];\n    this.keyRange = env.IDBKeyRange || env.webkitIDBKeyRange || env.mozIDBKeyRange;\n\n    this.consts = {\n      'READ_ONLY':         'readonly',\n      'READ_WRITE':        'readwrite',\n      'VERSION_CHANGE':    'versionchange',\n      'NEXT':              'next',\n      'NEXT_NO_DUPLICATE': 'nextunique',\n      'PREV':              'prev',\n      'PREV_NO_DUPLICATE': 'prevunique'\n    };\n\n    this.openDB();\n  };\n\n  /** @lends IDBStore.prototype */\n  var proto = {\n\n    /**\n     * A pointer to the IDBStore ctor\n     *\n     * @private\n     * @type {Function}\n     * @constructs\n     */\n    constructor: IDBStore,\n\n    /**\n     * The version of IDBStore\n     *\n     * @type {String}\n     */\n    version: '1.6.2',\n\n    /**\n     * A reference to the IndexedDB object\n     *\n     * @type {Object}\n     */\n    db: null,\n\n    /**\n     * The full name of the IndexedDB used by IDBStore, composed of\n     * this.storePrefix + this.storeName\n     *\n     * @type {String}\n     */\n    dbName: null,\n\n    /**\n     * The version of the IndexedDB used by IDBStore\n     *\n     * @type {Number}\n     */\n    dbVersion: null,\n\n    /**\n     * A reference to the objectStore used by IDBStore\n     *\n     * @type {Object}\n     */\n    store: null,\n\n    /**\n     * The store name\n     *\n     * @type {String}\n     */\n    storeName: null,\n\n    /**\n     * The prefix to prepend to the store name\n     *\n     * @type {String}\n     */\n    storePrefix: null,\n\n    /**\n     * The key path\n     *\n     * @type {String}\n     */\n    keyPath: null,\n\n    /**\n     * Whether IDBStore uses autoIncrement\n     *\n     * @type {Boolean}\n     */\n    autoIncrement: null,\n\n    /**\n     * The indexes used by IDBStore\n     *\n     * @type {Array}\n     */\n    indexes: null,\n\n    /**\n     * The implemantations to try to use, in order of preference\n     *\n     * @type {Array}\n     */\n    implementationPreference: null,\n\n    /**\n     * The actual implementation being used\n     *\n     * @type {String}\n     */\n    implementation: '',\n\n    /**\n     * The callback to be called when the store is ready to be used\n     *\n     * @type {Function}\n     */\n    onStoreReady: null,\n\n    /**\n     * The callback to be called if an error occurred during instantiation\n     * of the store\n     *\n     * @type {Function}\n     */\n    onError: null,\n\n    /**\n     * The internal insertID counter\n     *\n     * @type {Number}\n     * @private\n     */\n    _insertIdCount: 0,\n\n    /**\n     * Opens an IndexedDB; called by the constructor.\n     *\n     * Will check if versions match and compare provided index configuration\n     * with existing ones, and update indexes if necessary.\n     *\n     * Will call this.onStoreReady() if everything went well and the store\n     * is ready to use, and this.onError() is something went wrong.\n     *\n     * @private\n     *\n     */\n    openDB: function () {\n\n      var openRequest = this.idb.open(this.dbName, this.dbVersion);\n      var preventSuccessCallback = false;\n\n      openRequest.onerror = function (error) {\n\n        var gotVersionErr = false;\n        if ('error' in error.target) {\n          gotVersionErr = error.target.error.name == 'VersionError';\n        } else if ('errorCode' in error.target) {\n          gotVersionErr = error.target.errorCode == 12;\n        }\n\n        if (gotVersionErr) {\n          this.onError(new Error('The version number provided is lower than the existing one.'));\n        } else {\n          this.onError(error);\n        }\n      }.bind(this);\n\n      openRequest.onsuccess = function (event) {\n\n        if (preventSuccessCallback) {\n          return;\n        }\n\n        if(this.db){\n          this.onStoreReady();\n          return;\n        }\n\n        this.db = event.target.result;\n\n        if(typeof this.db.version == 'string'){\n          this.onError(new Error('The IndexedDB implementation in this browser is outdated. Please upgrade your browser.'));\n          return;\n        }\n\n        if(!this.db.objectStoreNames.contains(this.storeName)){\n          // We should never ever get here.\n          // Lets notify the user anyway.\n          this.onError(new Error('Object store couldn\\'t be created.'));\n          return;\n        }\n\n        var emptyTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n        this.store = emptyTransaction.objectStore(this.storeName);\n\n        // check indexes\n        var existingIndexes = Array.prototype.slice.call(this.getIndexList());\n        this.indexes.forEach(function(indexData){\n          var indexName = indexData.name;\n\n          if(!indexName){\n            preventSuccessCallback = true;\n            this.onError(new Error('Cannot create index: No index name given.'));\n            return;\n          }\n\n          this.normalizeIndexData(indexData);\n\n          if(this.hasIndex(indexName)){\n            // check if it complies\n            var actualIndex = this.store.index(indexName);\n            var complies = this.indexComplies(actualIndex, indexData);\n            if(!complies){\n              preventSuccessCallback = true;\n              this.onError(new Error('Cannot modify index \"' + indexName + '\" for current version. Please bump version number to ' + ( this.dbVersion + 1 ) + '.'));\n            }\n\n            existingIndexes.splice(existingIndexes.indexOf(indexName), 1);\n          } else {\n            preventSuccessCallback = true;\n            this.onError(new Error('Cannot create new index \"' + indexName + '\" for current version. Please bump version number to ' + ( this.dbVersion + 1 ) + '.'));\n          }\n\n        }, this);\n\n        if (existingIndexes.length) {\n          preventSuccessCallback = true;\n          this.onError(new Error('Cannot delete index(es) \"' + existingIndexes.toString() + '\" for current version. Please bump version number to ' + ( this.dbVersion + 1 ) + '.'));\n        }\n\n        preventSuccessCallback || this.onStoreReady();\n      }.bind(this);\n\n      openRequest.onupgradeneeded = function(/* IDBVersionChangeEvent */ event){\n\n        this.db = event.target.result;\n\n        if(this.db.objectStoreNames.contains(this.storeName)){\n          this.store = event.target.transaction.objectStore(this.storeName);\n        } else {\n          var optionalParameters = { autoIncrement: this.autoIncrement };\n          if (this.keyPath !== null) {\n            optionalParameters.keyPath = this.keyPath;\n          }\n          this.store = this.db.createObjectStore(this.storeName, optionalParameters);\n        }\n\n        var existingIndexes = Array.prototype.slice.call(this.getIndexList());\n        this.indexes.forEach(function(indexData){\n          var indexName = indexData.name;\n\n          if(!indexName){\n            preventSuccessCallback = true;\n            this.onError(new Error('Cannot create index: No index name given.'));\n          }\n\n          this.normalizeIndexData(indexData);\n\n          if(this.hasIndex(indexName)){\n            // check if it complies\n            var actualIndex = this.store.index(indexName);\n            var complies = this.indexComplies(actualIndex, indexData);\n            if(!complies){\n              // index differs, need to delete and re-create\n              this.store.deleteIndex(indexName);\n              this.store.createIndex(indexName, indexData.keyPath, { unique: indexData.unique, multiEntry: indexData.multiEntry });\n            }\n\n            existingIndexes.splice(existingIndexes.indexOf(indexName), 1);\n          } else {\n            this.store.createIndex(indexName, indexData.keyPath, { unique: indexData.unique, multiEntry: indexData.multiEntry });\n          }\n\n        }, this);\n\n        if (existingIndexes.length) {\n          existingIndexes.forEach(function(_indexName){\n            this.store.deleteIndex(_indexName);\n          }, this);\n        }\n\n      }.bind(this);\n    },\n\n    /**\n     * Deletes the database used for this store if the IDB implementations\n     * provides that functionality.\n     *\n     * @param {Function} [onSuccess] A callback that is called if deletion\n     *  was successful.\n     * @param {Function} [onError] A callback that is called if deletion\n     *  failed.\n     */\n    deleteDatabase: function (onSuccess, onError) {\n      if (this.idb.deleteDatabase) {\n        this.db.close();\n        var deleteRequest = this.idb.deleteDatabase(this.dbName);\n        deleteRequest.onsuccess = onSuccess;\n        deleteRequest.onerror = onError;\n      } else {\n        onError(new Error('Browser does not support IndexedDB deleteDatabase!'));\n      }\n    },\n\n    /*********************\n     * data manipulation *\n     *********************/\n\n    /**\n     * Puts an object into the store. If an entry with the given id exists,\n     * it will be overwritten. This method has a different signature for inline\n     * keys and out-of-line keys; please see the examples below.\n     *\n     * @param {*} [key] The key to store. This is only needed if IDBWrapper\n     *  is set to use out-of-line keys. For inline keys - the default scenario -\n     *  this can be omitted.\n     * @param {Object} value The data object to store.\n     * @param {Function} [onSuccess] A callback that is called if insertion\n     *  was successful.\n     * @param {Function} [onError] A callback that is called if insertion\n     *  failed.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     * @example\n        // Storing an object, using inline keys (the default scenario):\n        var myCustomer = {\n          customerid: 2346223,\n          lastname: 'Doe',\n          firstname: 'John'\n        };\n        myCustomerStore.put(myCustomer, mySuccessHandler, myErrorHandler);\n        // Note that passing success- and error-handlers is optional.\n     * @example\n        // Storing an object, using out-of-line keys:\n       var myCustomer = {\n         lastname: 'Doe',\n         firstname: 'John'\n       };\n       myCustomerStore.put(2346223, myCustomer, mySuccessHandler, myErrorHandler);\n      // Note that passing success- and error-handlers is optional.\n     */\n    put: function (key, value, onSuccess, onError) {\n      if (this.keyPath !== null) {\n        onError = onSuccess;\n        onSuccess = value;\n        value = key;\n      }\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = defaultSuccessHandler);\n\n      var hasSuccess = false,\n          result = null,\n          putRequest;\n\n      var putTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n      putTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n      putTransaction.onabort = onError;\n      putTransaction.onerror = onError;\n\n      if (this.keyPath !== null) { // in-line keys\n        this._addIdPropertyIfNeeded(value);\n        putRequest = putTransaction.objectStore(this.storeName).put(value);\n      } else { // out-of-line keys\n        putRequest = putTransaction.objectStore(this.storeName).put(value, key);\n      }\n      putRequest.onsuccess = function (event) {\n        hasSuccess = true;\n        result = event.target.result;\n      };\n      putRequest.onerror = onError;\n\n      return putTransaction;\n    },\n\n    /**\n     * Retrieves an object from the store. If no entry exists with the given id,\n     * the success handler will be called with null as first and only argument.\n     *\n     * @param {*} key The id of the object to fetch.\n     * @param {Function} [onSuccess] A callback that is called if fetching\n     *  was successful. Will receive the object as only argument.\n     * @param {Function} [onError] A callback that will be called if an error\n     *  occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    get: function (key, onSuccess, onError) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = defaultSuccessHandler);\n\n      var hasSuccess = false,\n          result = null;\n      \n      var getTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n      getTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n      getTransaction.onabort = onError;\n      getTransaction.onerror = onError;\n      var getRequest = getTransaction.objectStore(this.storeName).get(key);\n      getRequest.onsuccess = function (event) {\n        hasSuccess = true;\n        result = event.target.result;\n      };\n      getRequest.onerror = onError;\n\n      return getTransaction;\n    },\n\n    /**\n     * Removes an object from the store.\n     *\n     * @param {*} key The id of the object to remove.\n     * @param {Function} [onSuccess] A callback that is called if the removal\n     *  was successful.\n     * @param {Function} [onError] A callback that will be called if an error\n     *  occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    remove: function (key, onSuccess, onError) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = defaultSuccessHandler);\n\n      var hasSuccess = false,\n          result = null;\n\n      var removeTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n      removeTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n      removeTransaction.onabort = onError;\n      removeTransaction.onerror = onError;\n\n      var deleteRequest = removeTransaction.objectStore(this.storeName)['delete'](key);\n      deleteRequest.onsuccess = function (event) {\n        hasSuccess = true;\n        result = event.target.result;\n      };\n      deleteRequest.onerror = onError;\n\n      return removeTransaction;\n    },\n\n    /**\n     * Runs a batch of put and/or remove operations on the store.\n     *\n     * @param {Array} dataArray An array of objects containing the operation to run\n     *  and the data object (for put operations).\n     * @param {Function} [onSuccess] A callback that is called if all operations\n     *  were successful.\n     * @param {Function} [onError] A callback that is called if an error\n     *  occurred during one of the operations.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    batch: function (dataArray, onSuccess, onError) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = defaultSuccessHandler);\n\n      if(Object.prototype.toString.call(dataArray) != '[object Array]'){\n        onError(new Error('dataArray argument must be of type Array.'));\n      } else if (dataArray.length === 0) {\n        return onSuccess(true);\n      }\n\n      var count = dataArray.length;\n      var called = false;\n      var hasSuccess = false;\n\n      var batchTransaction = this.db.transaction([this.storeName] , this.consts.READ_WRITE);\n      batchTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(hasSuccess);\n      };\n      batchTransaction.onabort = onError;\n      batchTransaction.onerror = onError;\n\n\n      var onItemSuccess = function () {\n        count--;\n        if (count === 0 && !called) {\n          called = true;\n          hasSuccess = true;\n        }\n      };\n\n      dataArray.forEach(function (operation) {\n        var type = operation.type;\n        var key = operation.key;\n        var value = operation.value;\n\n        var onItemError = function (err) {\n          batchTransaction.abort();\n          if (!called) {\n            called = true;\n            onError(err, type, key);\n          }\n        };\n\n        if (type == 'remove') {\n          var deleteRequest = batchTransaction.objectStore(this.storeName)['delete'](key);\n          deleteRequest.onsuccess = onItemSuccess;\n          deleteRequest.onerror = onItemError;\n        } else if (type == 'put') {\n          var putRequest;\n          if (this.keyPath !== null) { // in-line keys\n            this._addIdPropertyIfNeeded(value);\n            putRequest = batchTransaction.objectStore(this.storeName).put(value);\n          } else { // out-of-line keys\n            putRequest = batchTransaction.objectStore(this.storeName).put(value, key);\n          }\n          putRequest.onsuccess = onItemSuccess;\n          putRequest.onerror = onItemError;\n        }\n      }, this);\n\n      return batchTransaction;\n    },\n\n    /**\n     * Takes an array of objects and stores them in a single transaction.\n     *\n     * @param {Array} dataArray An array of objects to store\n     * @param {Function} [onSuccess] A callback that is called if all operations\n     *  were successful.\n     * @param {Function} [onError] A callback that is called if an error\n     *  occurred during one of the operations.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    putBatch: function (dataArray, onSuccess, onError) {\n      var batchData = dataArray.map(function(item){\n        return { type: 'put', value: item };\n      });\n\n      return this.batch(batchData, onSuccess, onError);\n    },\n\n    /**\n     * Like putBatch, takes an array of objects and stores them in a single\n     * transaction, but allows processing of the result values.  Returns the\n     * processed records containing the key for newly created records to the\n     * onSuccess calllback instead of only returning true or false for success.\n     * In addition, added the option for the caller to specify a key field that\n     * should be set to the newly created key.\n     *\n     * @param {Array} dataArray An array of objects to store\n     * @param {Object} [options] An object containing optional options\n     * @param {String} [options.keyField=this.keyPath] Specifies a field in the record to update\n     *  with the auto-incrementing key. Defaults to the store's keyPath.\n     * @param {Function} [onSuccess] A callback that is called if all operations\n     *  were successful.\n     * @param {Function} [onError] A callback that is called if an error\n     *  occurred during one of the operations.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     *\n     */\n    upsertBatch: function (dataArray, options, onSuccess, onError) {\n      // handle `dataArray, onSuccess, onError` signature\n      if (typeof options == 'function') {\n        onSuccess = options;\n        onError = onSuccess;\n        options = {};\n      }\n\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = defaultSuccessHandler);\n      options || (options = {});\n\n      if (Object.prototype.toString.call(dataArray) != '[object Array]') {\n        onError(new Error('dataArray argument must be of type Array.'));\n      }\n\n      var keyField = options.keyField || this.keyPath;\n      var count = dataArray.length;\n      var called = false;\n      var hasSuccess = false;\n      var index = 0; // assume success callbacks are executed in order\n\n      var batchTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n      batchTransaction.oncomplete = function () {\n        if (hasSuccess) {\n          onSuccess(dataArray);\n        } else {\n          onError(false);\n        }\n      };\n      batchTransaction.onabort = onError;\n      batchTransaction.onerror = onError;\n\n      var onItemSuccess = function (event) {\n        var record = dataArray[index++];\n        record[keyField] = event.target.result;\n\n        count--;\n        if (count === 0 && !called) {\n          called = true;\n          hasSuccess = true;\n        }\n      };\n\n      dataArray.forEach(function (record) {\n        var key = record.key;\n\n        var onItemError = function (err) {\n          batchTransaction.abort();\n          if (!called) {\n            called = true;\n            onError(err);\n          }\n        };\n\n        var putRequest;\n        if (this.keyPath !== null) { // in-line keys\n          this._addIdPropertyIfNeeded(record);\n          putRequest = batchTransaction.objectStore(this.storeName).put(record);\n        } else { // out-of-line keys\n          putRequest = batchTransaction.objectStore(this.storeName).put(record, key);\n        }\n        putRequest.onsuccess = onItemSuccess;\n        putRequest.onerror = onItemError;\n      }, this);\n\n      return batchTransaction;\n    },\n\n    /**\n     * Takes an array of keys and removes matching objects in a single\n     * transaction.\n     *\n     * @param {Array} keyArray An array of keys to remove\n     * @param {Function} [onSuccess] A callback that is called if all operations\n     *  were successful.\n     * @param {Function} [onError] A callback that is called if an error\n     *  occurred during one of the operations.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    removeBatch: function (keyArray, onSuccess, onError) {\n      var batchData = keyArray.map(function(key){\n        return { type: 'remove', key: key };\n      });\n\n      return this.batch(batchData, onSuccess, onError);\n    },\n\n    /**\n     * Takes an array of keys and fetches matching objects\n     *\n     * @param {Array} keyArray An array of keys identifying the objects to fetch\n     * @param {Function} [onSuccess] A callback that is called if all operations\n     *  were successful.\n     * @param {Function} [onError] A callback that is called if an error\n     *  occurred during one of the operations.\n     * @param {String} [arrayType='sparse'] The type of array to pass to the\n     *  success handler. May be one of 'sparse', 'dense' or 'skip'. Defaults to\n     *  'sparse'. This parameter specifies how to handle the situation if a get\n     *  operation did not throw an error, but there was no matching object in\n     *  the database. In most cases, 'sparse' provides the most desired\n     *  behavior. See the examples for details.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     * @example\n     // given that there are two objects in the database with the keypath\n     // values 1 and 2, and the call looks like this:\n     myStore.getBatch([1, 5, 2], onError, function (data) { … }, arrayType);\n\n     // this is what the `data` array will be like:\n\n     // arrayType == 'sparse':\n     // data is a sparse array containing two entries and having a length of 3:\n       [Object, 2: Object]\n         0: Object\n         2: Object\n         length: 3\n         __proto__: Array[0]\n     // calling forEach on data will result in the callback being called two\n     // times, with the index parameter matching the index of the key in the\n     // keyArray.\n\n     // arrayType == 'dense':\n     // data is a dense array containing three entries and having a length of 3,\n     // where data[1] is of type undefined:\n       [Object, undefined, Object]\n         0: Object\n         1: undefined\n         2: Object\n         length: 3\n         __proto__: Array[0]\n     // calling forEach on data will result in the callback being called three\n     // times, with the index parameter matching the index of the key in the\n     // keyArray, but the second call will have undefined as first argument.\n\n     // arrayType == 'skip':\n     // data is a dense array containing two entries and having a length of 2:\n       [Object, Object]\n         0: Object\n         1: Object\n         length: 2\n         __proto__: Array[0]\n     // calling forEach on data will result in the callback being called two\n     // times, with the index parameter not matching the index of the key in the\n     // keyArray.\n     */\n    getBatch: function (keyArray, onSuccess, onError, arrayType) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = defaultSuccessHandler);\n      arrayType || (arrayType = 'sparse');\n\n      if (Object.prototype.toString.call(keyArray) != '[object Array]'){\n        onError(new Error('keyArray argument must be of type Array.'));\n      } else if (keyArray.length === 0) {\n        return onSuccess([]);\n      }\n\n      var data = [];\n      var count = keyArray.length;\n      var called = false;\n      var hasSuccess = false;\n      var result = null;\n\n      var batchTransaction = this.db.transaction([this.storeName] , this.consts.READ_ONLY);\n      batchTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n      batchTransaction.onabort = onError;\n      batchTransaction.onerror = onError;\n\n      var onItemSuccess = function (event) {\n        if (event.target.result || arrayType == 'dense') {\n          data.push(event.target.result);\n        } else if (arrayType == 'sparse') {\n          data.length++;\n        }\n        count--;\n        if (count === 0) {\n          called = true;\n          hasSuccess = true;\n          result = data;\n        }\n      };\n\n      keyArray.forEach(function (key) {\n\n        var onItemError = function (err) {\n          called = true;\n          result = err;\n          onError(err);\n          batchTransaction.abort();\n        };\n\n        var getRequest = batchTransaction.objectStore(this.storeName).get(key);\n        getRequest.onsuccess = onItemSuccess;\n        getRequest.onerror = onItemError;\n\n      }, this);\n\n      return batchTransaction;\n    },\n\n    /**\n     * Fetches all entries in the store.\n     *\n     * @param {Function} [onSuccess] A callback that is called if the operation\n     *  was successful. Will receive an array of objects.\n     * @param {Function} [onError] A callback that will be called if an error\n     *  occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    getAll: function (onSuccess, onError) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = defaultSuccessHandler);\n      var getAllTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n      var store = getAllTransaction.objectStore(this.storeName);\n      if (store.getAll) {\n        this._getAllNative(getAllTransaction, store, onSuccess, onError);\n      } else {\n        this._getAllCursor(getAllTransaction, store, onSuccess, onError);\n      }\n\n      return getAllTransaction;\n    },\n\n    /**\n     * Implements getAll for IDB implementations that have a non-standard\n     * getAll() method.\n     *\n     * @param {Object} getAllTransaction An open READ transaction.\n     * @param {Object} store A reference to the store.\n     * @param {Function} onSuccess A callback that will be called if the\n     *  operation was successful.\n     * @param {Function} onError A callback that will be called if an\n     *  error occurred during the operation.\n     * @private\n     */\n    _getAllNative: function (getAllTransaction, store, onSuccess, onError) {\n      var hasSuccess = false,\n          result = null;\n\n      getAllTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n      getAllTransaction.onabort = onError;\n      getAllTransaction.onerror = onError;\n\n      var getAllRequest = store.getAll();\n      getAllRequest.onsuccess = function (event) {\n        hasSuccess = true;\n        result = event.target.result;\n      };\n      getAllRequest.onerror = onError;\n    },\n\n    /**\n     * Implements getAll for IDB implementations that do not have a getAll()\n     * method.\n     *\n     * @param {Object} getAllTransaction An open READ transaction.\n     * @param {Object} store A reference to the store.\n     * @param {Function} onSuccess A callback that will be called if the\n     *  operation was successful.\n     * @param {Function} onError A callback that will be called if an\n     *  error occurred during the operation.\n     * @private\n     */\n    _getAllCursor: function (getAllTransaction, store, onSuccess, onError) {\n      var all = [],\n          hasSuccess = false,\n          result = null;\n\n      getAllTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n      getAllTransaction.onabort = onError;\n      getAllTransaction.onerror = onError;\n\n      var cursorRequest = store.openCursor();\n      cursorRequest.onsuccess = function (event) {\n        var cursor = event.target.result;\n        if (cursor) {\n          all.push(cursor.value);\n          cursor['continue']();\n        }\n        else {\n          hasSuccess = true;\n          result = all;\n        }\n      };\n      cursorRequest.onError = onError;\n    },\n\n    /**\n     * Clears the store, i.e. deletes all entries in the store.\n     *\n     * @param {Function} [onSuccess] A callback that will be called if the\n     *  operation was successful.\n     * @param {Function} [onError] A callback that will be called if an\n     *  error occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    clear: function (onSuccess, onError) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = defaultSuccessHandler);\n\n      var hasSuccess = false,\n          result = null;\n\n      var clearTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n      clearTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n      clearTransaction.onabort = onError;\n      clearTransaction.onerror = onError;\n\n      var clearRequest = clearTransaction.objectStore(this.storeName).clear();\n      clearRequest.onsuccess = function (event) {\n        hasSuccess = true;\n        result = event.target.result;\n      };\n      clearRequest.onerror = onError;\n\n      return clearTransaction;\n    },\n\n    /**\n     * Checks if an id property needs to present on a object and adds one if\n     * necessary.\n     *\n     * @param {Object} dataObj The data object that is about to be stored\n     * @private\n     */\n    _addIdPropertyIfNeeded: function (dataObj) {\n      if (typeof dataObj[this.keyPath] == 'undefined') {\n        dataObj[this.keyPath] = this._insertIdCount++ + Date.now();\n      }\n    },\n\n    /************\n     * indexing *\n     ************/\n\n    /**\n     * Returns a DOMStringList of index names of the store.\n     *\n     * @return {DOMStringList} The list of index names\n     */\n    getIndexList: function () {\n      return this.store.indexNames;\n    },\n\n    /**\n     * Checks if an index with the given name exists in the store.\n     *\n     * @param {String} indexName The name of the index to look for\n     * @return {Boolean} Whether the store contains an index with the given name\n     */\n    hasIndex: function (indexName) {\n      return this.store.indexNames.contains(indexName);\n    },\n\n    /**\n     * Normalizes an object containing index data and assures that all\n     * properties are set.\n     *\n     * @param {Object} indexData The index data object to normalize\n     * @param {String} indexData.name The name of the index\n     * @param {String} [indexData.keyPath] The key path of the index\n     * @param {Boolean} [indexData.unique] Whether the index is unique\n     * @param {Boolean} [indexData.multiEntry] Whether the index is multi entry\n     */\n    normalizeIndexData: function (indexData) {\n      indexData.keyPath = indexData.keyPath || indexData.name;\n      indexData.unique = !!indexData.unique;\n      indexData.multiEntry = !!indexData.multiEntry;\n    },\n\n    /**\n     * Checks if an actual index complies with an expected index.\n     *\n     * @param {Object} actual The actual index found in the store\n     * @param {Object} expected An Object describing an expected index\n     * @return {Boolean} Whether both index definitions are identical\n     */\n    indexComplies: function (actual, expected) {\n      var complies = ['keyPath', 'unique', 'multiEntry'].every(function (key) {\n        // IE10 returns undefined for no multiEntry\n        if (key == 'multiEntry' && actual[key] === undefined && expected[key] === false) {\n          return true;\n        }\n        // Compound keys\n        if (key == 'keyPath' && Object.prototype.toString.call(expected[key]) == '[object Array]') {\n          var exp = expected.keyPath;\n          var act = actual.keyPath;\n\n          // IE10 can't handle keyPath sequences and stores them as a string.\n          // The index will be unusable there, but let's still return true if\n          // the keyPath sequence matches.\n          if (typeof act == 'string') {\n            return exp.toString() == act;\n          }\n\n          // Chrome/Opera stores keyPath squences as DOMStringList, Firefox\n          // as Array\n          if ( ! (typeof act.contains == 'function' || typeof act.indexOf == 'function') ) {\n            return false;\n          }\n\n          if (act.length !== exp.length) {\n            return false;\n          }\n\n          for (var i = 0, m = exp.length; i<m; i++) {\n            if ( ! ( (act.contains && act.contains(exp[i])) || act.indexOf(exp[i] !== -1) )) {\n              return false;\n            }\n          }\n          return true;\n        }\n        return expected[key] == actual[key];\n      });\n      return complies;\n    },\n\n    /**********\n     * cursor *\n     **********/\n\n    /**\n     * Iterates over the store using the given options and calling onItem\n     * for each entry matching the options.\n     *\n     * @param {Function} onItem A callback to be called for each match\n     * @param {Object} [options] An object defining specific options\n     * @param {Object} [options.index=null] An IDBIndex to operate on\n     * @param {String} [options.order=ASC] The order in which to provide the\n     *  results, can be 'DESC' or 'ASC'\n     * @param {Boolean} [options.autoContinue=true] Whether to automatically\n     *  iterate the cursor to the next result\n     * @param {Boolean} [options.filterDuplicates=false] Whether to exclude\n     *  duplicate matches\n     * @param {Object} [options.keyRange=null] An IDBKeyRange to use\n     * @param {Boolean} [options.writeAccess=false] Whether grant write access\n     *  to the store in the onItem callback\n     * @param {Function} [options.onEnd=null] A callback to be called after\n     *  iteration has ended\n     * @param {Function} [options.onError=throw] A callback to be called\n     *  if an error occurred during the operation.\n     * @param {Number} [options.limit=Infinity] Limit the number of returned\n     *  results to this number\n     * @param {Number} [options.offset=0] Skip the provided number of results\n     *  in the resultset\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    iterate: function (onItem, options) {\n      options = mixin({\n        index: null,\n        order: 'ASC',\n        autoContinue: true,\n        filterDuplicates: false,\n        keyRange: null,\n        writeAccess: false,\n        onEnd: null,\n        onError: defaultErrorHandler,\n        limit: Infinity,\n        offset: 0\n      }, options || {});\n\n      var directionType = options.order.toLowerCase() == 'desc' ? 'PREV' : 'NEXT';\n      if (options.filterDuplicates) {\n        directionType += '_NO_DUPLICATE';\n      }\n\n      var hasSuccess = false;\n      var cursorTransaction = this.db.transaction([this.storeName], this.consts[options.writeAccess ? 'READ_WRITE' : 'READ_ONLY']);\n      var cursorTarget = cursorTransaction.objectStore(this.storeName);\n      if (options.index) {\n        cursorTarget = cursorTarget.index(options.index);\n      }\n      var recordCount = 0;\n\n      cursorTransaction.oncomplete = function () {\n        if (!hasSuccess) {\n          options.onError(null);\n          return;\n        }\n        if (options.onEnd) {\n          options.onEnd();\n        } else {\n          onItem(null);\n        }\n      };\n      cursorTransaction.onabort = options.onError;\n      cursorTransaction.onerror = options.onError;\n\n      var cursorRequest = cursorTarget.openCursor(options.keyRange, this.consts[directionType]);\n      cursorRequest.onerror = options.onError;\n      cursorRequest.onsuccess = function (event) {\n        var cursor = event.target.result;\n        if (cursor) {\n          if (options.offset) {\n            cursor.advance(options.offset);\n            options.offset = 0;\n          } else {\n            onItem(cursor.value, cursor, cursorTransaction);\n            recordCount++;\n            if (options.autoContinue) {\n              if (recordCount + options.offset < options.limit) {\n                cursor['continue']();\n              } else {\n                hasSuccess = true;\n              }\n            }\n          }\n        } else {\n          hasSuccess = true;\n        }\n      };\n\n      return cursorTransaction;\n    },\n\n    /**\n     * Runs a query against the store and passes an array containing matched\n     * objects to the success handler.\n     *\n     * @param {Function} onSuccess A callback to be called when the operation\n     *  was successful.\n     * @param {Object} [options] An object defining specific options\n     * @param {Object} [options.index=null] An IDBIndex to operate on\n     * @param {String} [options.order=ASC] The order in which to provide the\n     *  results, can be 'DESC' or 'ASC'\n     * @param {Boolean} [options.filterDuplicates=false] Whether to exclude\n     *  duplicate matches\n     * @param {Object} [options.keyRange=null] An IDBKeyRange to use\n     * @param {Function} [options.onError=throw] A callback to be called\n     *  if an error occurred during the operation.\n     * @param {Number} [options.limit=Infinity] Limit the number of returned\n     *  results to this number\n     * @param {Number} [options.offset=0] Skip the provided number of results\n     *  in the resultset\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    query: function (onSuccess, options) {\n      var result = [];\n      options = options || {};\n      options.autoContinue = true;\n      options.writeAccess = false;\n      options.onEnd = function () {\n        onSuccess(result);\n      };\n      return this.iterate(function (item) {\n        result.push(item);\n      }, options);\n    },\n\n    /**\n     *\n     * Runs a query against the store, but only returns the number of matches\n     * instead of the matches itself.\n     *\n     * @param {Function} onSuccess A callback to be called if the opration\n     *  was successful.\n     * @param {Object} [options] An object defining specific options\n     * @param {Object} [options.index=null] An IDBIndex to operate on\n     * @param {Object} [options.keyRange=null] An IDBKeyRange to use\n     * @param {Function} [options.onError=throw] A callback to be called if an error\n     *  occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    count: function (onSuccess, options) {\n\n      options = mixin({\n        index: null,\n        keyRange: null\n      }, options || {});\n\n      var onError = options.onError || defaultErrorHandler;\n\n      var hasSuccess = false,\n          result = null;\n\n      var cursorTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n      cursorTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n      cursorTransaction.onabort = onError;\n      cursorTransaction.onerror = onError;\n\n      var cursorTarget = cursorTransaction.objectStore(this.storeName);\n      if (options.index) {\n        cursorTarget = cursorTarget.index(options.index);\n      }\n      var countRequest = cursorTarget.count(options.keyRange);\n      countRequest.onsuccess = function (evt) {\n        hasSuccess = true;\n        result = evt.target.result;\n      };\n      countRequest.onError = onError;\n\n      return cursorTransaction;\n    },\n\n    /**************/\n    /* key ranges */\n    /**************/\n\n    /**\n     * Creates a key range using specified options. This key range can be\n     * handed over to the count() and iterate() methods.\n     *\n     * Note: You must provide at least one or both of \"lower\" or \"upper\" value.\n     *\n     * @param {Object} options The options for the key range to create\n     * @param {*} [options.lower] The lower bound\n     * @param {Boolean} [options.excludeLower] Whether to exclude the lower\n     *  bound passed in options.lower from the key range\n     * @param {*} [options.upper] The upper bound\n     * @param {Boolean} [options.excludeUpper] Whether to exclude the upper\n     *  bound passed in options.upper from the key range\n     * @param {*} [options.only] A single key value. Use this if you need a key\n     *  range that only includes one value for a key. Providing this\n     *  property invalidates all other properties.\n     * @return {Object} The IDBKeyRange representing the specified options\n     */\n    makeKeyRange: function(options){\n      /*jshint onecase:true */\n      var keyRange,\n          hasLower = typeof options.lower != 'undefined',\n          hasUpper = typeof options.upper != 'undefined',\n          isOnly = typeof options.only != 'undefined';\n\n      switch(true){\n        case isOnly:\n          keyRange = this.keyRange.only(options.only);\n          break;\n        case hasLower && hasUpper:\n          keyRange = this.keyRange.bound(options.lower, options.upper, options.excludeLower, options.excludeUpper);\n          break;\n        case hasLower:\n          keyRange = this.keyRange.lowerBound(options.lower, options.excludeLower);\n          break;\n        case hasUpper:\n          keyRange = this.keyRange.upperBound(options.upper, options.excludeUpper);\n          break;\n        default:\n          throw new Error('Cannot create KeyRange. Provide one or both of \"lower\" or \"upper\" value, or an \"only\" value.');\n      }\n\n      return keyRange;\n\n    }\n\n  };\n\n  /** helpers **/\n  var empty = {};\n  function mixin (target, source) {\n    var name, s;\n    for (name in source) {\n      s = source[name];\n      if (s !== empty[name] && s !== target[name]) {\n        target[name] = s;\n      }\n    }\n    return target;\n  }\n\n  IDBStore.prototype = proto;\n  IDBStore.version = proto.version;\n\n  return IDBStore;\n\n}, this);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/idb-wrapper/idbstore.js\n ** module id = 14\n ** module chunks = 1\n **/","'use strict'\n\n/* global self:false, fetch:false, __DEV__:false */\n\nimport IDBStore from 'idb-wrapper'\nimport serialiseRequest from 'serialise-request'\nimport serialiseResponse from 'serialise-response'\n\nimport Channel from '/fetchSync/worker/Channel'\nimport { SyncTypes } from '/fetchSync/constants'\nimport { Requests, Responses } from '/fetchSync/actionTypes'\n\nconst store = new IDBStore({\n  dbVersion: 1,\n  keyPath: 'id',\n  storeName: __DEV__\n    ? '$$syncs_' + Date.now()\n    : '$$syncs'\n})\n\nconst channel = new Channel(self, {\n  [Requests.OPEN_COMMS]: (event) => {\n    channel.setDefaultPort(event.ports[0])\n    return Promise.resolve()\n  },\n  [Requests.REGISTER_SYNC]: ({ data }) => {\n    return registerSync(data.sync)\n      .then(() => addSync(data.sync))\n  },\n  [Requests.CANCEL_SYNC]: ({ data }) => {\n    return new Promise(store.remove.bind(store, data.id))\n  },\n  [Requests.CANCEL_ALL]: () => {\n    return new Promise(store.getAll.bind(store))\n      .then((syncs) => new Promise(\n        store.removeBatch.bind(store, syncs.map((sync) => sync.id))\n      ))\n  }\n})\n\nfunction registerSync (sync) {\n  if (!self.registration[sync.type]) {\n    return Promise.reject(new Error(`Background '${sync.type}' not supported`))\n  }\n\n  const tag = sync.type === SyncTypes.PERIODIC_SYNC\n    ? { ...sync.options, tag: sync.id }\n    : sync.id\n\n  return self\n    .registration[sync.type]\n    .register(tag)\n}\n\nfunction addSync (sync) {\n  return new Promise(store.put.bind(store, sync))\n    .catch((err) => {\n      if (!/key already exists/i.test(err.message)) {\n        throw err\n      }\n    })\n}\n\nfunction syncEvent (event) {\n  event.waitUntil(\n    new Promise(store.get.bind(store, event.tag))\n      .then((sync) => {\n        if (!sync) {\n          event.registration && event.registration.unregister()\n          return\n        }\n\n        const id = sync.id\n        const lastChance = event.lastChance\n        const request = serialiseRequest.deserialise(sync.request)\n\n        return fetch(request)\n          .then(serialiseResponse)\n          .then((response) => {\n            const syncedOn = Date.now()\n            store.put({ ...sync, response, syncedOn })\n            channel.postMessage({\n              type: Responses.SUCCESS,\n              data: { id, lastChance, response }\n            })\n          })\n          .catch((err) => {\n            store.remove(id)\n            channel.postMessage({\n              type: Responses.FAILURE,\n              data: { error: err.message }\n            })\n          })\n      })\n  )\n}\n\n// The 'sync' and 'periodicSync' events fire when connectivity\n// is restored or already available to the UA.\nself.addEventListener(SyncTypes.SYNC, syncEvent)\nself.addEventListener(SyncTypes.PERIODIC_SYNC, syncEvent)\n\n// The 'activate' event is fired when the service worker becomes operational.\n// For example, after a refresh after install, or after all pages using\n// the older version of the worker have closed after upgrade of the worker.\nself.addEventListener('activate', function activateEvent (event) {\n  event.waitUntil(self.clients.claim())\n})\n\n// The 'install' event is fired when the service worker has been installed.\n// This does not mean that the service worker is operating, as the UA will wait\n// for all pages to close that are using older versions of the worker.\nself.addEventListener('install', function installEvent (event) {\n  event.waitUntil(self.skipWaiting())\n})\n\n\n\n/** WEBPACK FOOTER **\n ** C:/xampp/htdocs/fetch-sync/fetchSync/worker/index.js\n **/"],"sourceRoot":""}